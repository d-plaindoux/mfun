<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Compiling F&micro;N language</title>

    <meta name="description" content="Functional language compilation">
    <meta name="author" content="Didier Plaindoux">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <script type="application/javascript" src="../dist/mFun.min.js"></script>

    <script type="application/mfun">
    def setDom { n v     -> native "set"   }
    def getDom { n       -> native "get"   }

    def leq    { l r t f -> native "leq"   }
    def plus   { l r     -> native "plus" }
    def mult   { l r     -> native "mult"  }
    def minus  { l r     -> native "minus" }
    </script>

    <script type="application/mfun">
    def changeDom { n v -> do { setDom (getDom n) v } yield { v } }

    def cond   { c t f -> c t f () }

    def do    { f   -> then () f }
    def then  { v f -> { v c -> c v } $ f v }
    def yield { v f  -> f v }
    </script>

    <script type="application/mfun">
    def fact { a ->
        cond (leq a 1)
             { 1 }
             { mult a $ fact $ minus a 1 }
    }
    </script>

    <script type="application/javascript">
        function evalPrint(sourceCode) {
            console.log("Executing [" + sourceCode + "]");
            mFun.default.eval_print(sourceCode);
        }

        function bootstrap() {
            mFun.default.reader.browser(evalPrint);
        }
    </script>

    <style>

        .alert {
            font-size: 55% !important;
            color: white;
            text-align: center !important;
            background-color: #994422;
            padding: 1em 0em 1em 0em !important;
            Box-shadow: 5px 5px 5px 0px rgba(0, 0, 0, 0.4);
        }

        .tk {
            font-style: revert;
            color: #00BBFF;
        }

        .remark {
            font-size: 55% !important;
            color: white;
            text-align: middle !important;
            background-color: #445566;
            padding: 1em 0em 1em 0em !important;
            Box-shadow: 5px 5px 5px 0px rgba(0, 0, 0, 0.4);
        }

        .name {
            text-transform: none !important;
        }

        .ribbon {
            position: fixed;
            right: 0px;
            top: 0px;
            z-index: 1;
            overflow: hidden;
            width: 150px;
            height: 120px;
            text-align: right;
        }

        .ribbon span {
            font-size: 10px;
            font-weight: bold;
            color: #FFF;
            text-transform: uppercase;
            text-align: center;
            line-height: 20px;
            transform: rotate(45deg);
            -webkit-transform: rotate(45deg);
            width: 120px;
            display: block;
            background: #79A70A;
            background: linear-gradient(#F70505 0%, #8F0808 100%);
            box-shadow: 0 3px 10px -5px rgba(0, 0, 0, 1);
            position: absolute;
            top: 24px;
            right: -26px;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
<div class="reveal">
    <div class="slides">

        <section>
            <h2><span class="name">F&micro;N</span></h2>
            <h3> From Definition to Execution </h3>
            <br/>
            <div class="p" style="text-align:middle">20 septembre 2017</div>
            <div class="p" style="text-align:middle">Software Craftsmanship Toulouse</div>
            <div class="p" style="text-align:middle">
	    <span>
	      <a href="http://twitter.com/dplaindoux">@dplaindoux</a>
          &amp;
          <a href="http://twitter.com/fcabestre">@fcabestre</a>
	    </span>
            </div>
        </section>

        <section>
            <h3> Language Definition </h3>

            <ul>
                <li> &lambda;-Calculus: variable, abstraction and application</li>
                <li> Constant: number and string</li>
                <li> Definition: function and constant</li>
                <li> Native: function and constant</li>
            </ul>

        </section>

        <section>
            <h3> Language Grammar </h3>
            <pre class="remark">
          exp  ::= sexp sexp*
          sexp ::= <span class="tk">{</span> (IDENT+ <span class="tk">-></span>)? exp <span class="tk">}</span> -- Ã  la Swift or Kotlin
                 | <span class="tk">(</span> exp? <span class="tk">)</span>
                 | <span class="tk">$</span> exp                -- Infix application
                 | IDENT
                 | NUMBER
                 | STRING
                 | <span class="tk">native</span> STRING
          def  ::= <span class="tk">def</span> IDENT sexp
                 | exp
          s0   ::= def* </pre>

            <div class="remark fragment"> LL(1)?</div>
        </section>

        <section>
            <h3> syntax highlights </h3>

            <div class="remark">
                <table width="100%">
                    <tr>
                        <td width="30%" align="right"><tt> a (b (c d))</tt></td>
                        <td width="2%">&equiv;</td>
                        <td width="20%"><tt> a $ b $ c d </tt></td>
                        <td> Infix Application</td>
                    </tr>
                    <tr>
                        <td width="30%" align="right"><tt> { a -> { b -> ... } } </tt></td>
                        <td width="2%">&equiv;</td>
                        <td width="20%"><tt> { a b -> ... } </tt></td>
                        <td> Currified form</td>
                    </tr>
                    <tr>
                        <td width="30%" align="right"><tt> { a -> f a } </tt></td>
                        <td width="2%">&equiv;</td>
                        <td width="20%"><tt> { f _ } </tt></td>
                        <td> Implicit argument</td>
                    </tr>
                </table>
            </div>

            <div class="alert fragment">
                <table width="100%">
                    <tr>
                        <td width="30%" align="right"><tt> { f a } </tt></td>
                        <td width="2%">&nequiv;</td>
                        <td width="20%"><tt> ( f a ) </tt></td>
                        <td> Abstraction vs. Application</td>
                    </tr>
                    <tr>
                        <td width="30%" align="right"><tt> { a -> { b -> f a } } </tt></td>
                        <td width="2%">&nequiv;</td>
                        <td width="20%"><tt> { { f _ } } </tt></td>
                        <td> Implicit variable scope</td>
                    </tr>
                </table>
            </div>
        </section>

        <section>
            <h3> Example :: Factorial </h3>
            <pre><code class="mfun">
    def leq   { l r t f in native "leq"   } // l <= r ? t : f
    def mult  { l r     -> native "mult"  }
    def minus { l r     -> native "minus" }

    def cond { c t f -> c t f () }

    def fact { a ->
       cond (leq a 1)
            { _ -> 1 }
            { _ -> mult a (fact (minus a 1)) }
    }

    fact 12
      </code></pre>
        </section>

        <section>
            <h3> Example :: Factorial Cont'd </h3>
            <pre><code class="mfun">
    def leq   { l r t f -> native "leq"   } // l <= r ? t : f
    def mult  { l r     -> native "mult"  }
    def minus { l r     -> native "minus" }

    def cond { c t f -> c t f () }

    def fact { a ->
       cond (leq a 1)
            { 1 }
            { mult a $ fact $ minus a 1 }
    }

    fact 12
      </code></pre>
        </section>

        <section>
            <h3> Example :: DSL </h3>
            <pre><code class="mfun">
    def do    { f   -> then () f }
    def then  { v f -> { v c -> c v } $ f v }
    def yield { v f -> f v }

    do    { plus 20 2 }
    then  { minus _ 1 }
    yield { mult _ 2 } // 42
            </code></pre>
        </section>

        <section>
            <h3> Analyze </h3>

            Sequence char &rightarrow; Try Ast
        </section>

        <section>
            <h3> (parser char Token).chain(parser Token Ast) </h3>

            <div>
                <ul>
                    <li>
                        <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">
                            Parser Combinators </a></li>
                    <li> Generic lexer cf. <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Genlex.html">
                        OCaml
                        Genlex </a></li>
                </ul>
            </div>

            <br>

            <div class="remark fragment"> LL(1) or when k > 1 with try parser i.e. backtrack</div>
        </section>

        <section>
            <h3> From concrete syntax to abstract syntax </h3>

            <pre>

 [_] :: Sequence Token &rightarrow; Ast

 [<span class="tk">{</span> a <span class="tk">-></span> b <span class="tk">}</span>] = Ast.abstraction(a, [b]))
 [a b]        = Ast.application([a],[b])
 [i]          = Ast.ident(i)             if i &in; IDENT
 [n]          = Ast.constant(n)          if n &in; NUMBER &cup; STRING
 [<span class="tk">native</span> s]   = Ast.native(s)
 [<span class="tk">(</span> a <span class="tk">)</span>]      = [a]
 [<span class="tk">$</span> a]        = [a]
 [<span class="tk">()</span>]         = Ast.constant(unit)
      </pre>

            <div class="fragment ribbon"><span>Live Code</span></div>
        </section>

        <section>
            <h3> Transform </h3>
            Ast &rightarrow; AstDB
        </section>

        <section>
            <h3> De Bruijn index </h3>

            <p>
                <img class="plain" src="images/De_Bruijn_index.png">
            </p>

            <ul>
                <li type="none"> Invariant with respect to &alpha;-conversion</li>
                <li type="none"> Direct access in an environment</li>
            </ul>

        </section>

        <section>
            <h3> Determine De Bruijn indexes </h3>

            <pre>

 [_] :: Ast &rightarrow; List String &rightarrow; AstDB

 [Ast.constant(c)]<sub>e</sub>       = AstDB.constant(c)
 [Ast.native(c)]<sub>e</sub>         = AstDB.native(c)
 [Ast.application(a,b)]<sub>e</sub>  = AstDB.application([a]<sub>e</sub>, [b]<sub>e</sub>)
 [Ast.abstraction(a,b)]<sub>e</sub>  = AstDB.abstraction([b]<sub>(a::e)</sub>)
 [Ast.ident(n)]<sub>e</sub>          = AstDB.ident(n)    if &forall; i   / e[i]&ne;n
 [Ast.ident(n)]<sub>e</sub>          = AstDB.variable(i) if &exist; i   / e[i]=n
                                                 &forall; j&lt;i / e[j]&ne;n
      </pre>

            <div class="fragment ribbon"><span>Live Code</span></div>
        </section>

        <section>
            <h3> Interpret </h3>

            AstDB &rightarrow; Result
        </section>

        <section>
            <h3> Advanced Interpreter </h3>

            <pre>

 type Result = NUMBER | STRING | (AstDB,Env)
  and Env    = List Result
 [_] :: AstDB &rightarrow; Env &rightarrow; Result

 [AstDB.constant(c)]<sub>e</sub>       = c
 [AstDB.variable(i)]<sub>e</sub>       = e[i]
 [AstDB.abstraction(b)]<sub>e</sub>    = (b,e)
 [AstDB.application(a,b)]<sub>e</sub>  = [c]<sub>d::e'</sub> when [a]<sub>e</sub> =<sub>*</sub> (c,e')
                                        and [b]<sub>e</sub> =<sub>*</sub> d
            </pre>

            <div class="remark fragment">
                No &beta;-reduction based on term subtitution <br>
            </div>
            <div class="alert fragment">
                Application interpretation is not tail recursive
            </div>

        </section>

        <section>
            <h3> Compile </h3>

            <p> AstDB &rightarrow; Objcode </p>

        </section>

        <section>
            <h3> Abstract machine </h3>

            <ul>
                <li> J-L. Krivine's machine</li>
                <li> X. Leroy's ZINC abstract machine</li>
            </ul>
        </section>

        <section>
            <h3> Compilation process </h3>

            <pre>

 [_] :: AstDB &rightarrow; Objcode

 [AstDB.variable(i)]      = Objcode.access(i)
 [AstDB.application(a,b)] = [a];[b];Objcode.apply
 [AstDB.abstraction(b)]   = Objcode.closure([b];Objcode.returns)

 [AstDB.ident(n)]         = Objcode.ident(n)
 [AstDB.constant(c)]      = Objcode.constant(c)
 [AstDB.native(c)]        = Objcode.native(c)
      </pre>

            <div class="fragment remark"> Standard call-by-value</div>
            <div class="fragment ribbon"><span>Live Code</span></div>
        </section>

        <section>
            <h3> Execute </h3>
            Objcode &rightarrow; Try Result
        </section>

        <section>
            <h3> Execution process :: Core </h3>

            <pre>

 type Result = NUMBER | STRING | (Objcode,Env)
  and Env    = List Result
  and Stack  = List (Result | Env | Objcode)

 [_] :: Objcode &rightarrow; Env &rightarrow; Stack &rightarrow; Result

 [Objcode.constant(n);c]<sub>e s</sub>        = [c]<sub>e n::s</sub>
 [Objcode.access(i);c]<sub>e s</sub>          = [c]<sub>e e[i]::s</sub>
 [Objcode.closure(c');c]<sub>e s</sub>        = [c]<sub>e (c',e)::s</sub>
 [Objcode.apply;c]<sub>e v::(c',e')::s</sub>  = [c']<sub>v::e' c::e::s</sub>
 [Objcode.returns;c]<sub>e v::c'::e'::s</sub> = [c']<sub>e' v::s</sub>
 ...
    </pre>

            <div class="fragment ribbon"><span>Live Code</span></div>

        </section>

        <section>
            <h3> Execution process :: Extension </h3>

            <pre>

 ...
 definition :: String -> Result
 native     :: String -> Env -> Result

 [Objcode.ident(n);c]<sub>e s</sub>              = [c]<sub>e (definition n)::s</sub>
 [Objcode.native(n);c]<sub>e s</sub>             = [c]<sub>e (native n e)::s</sub>
  </pre>

            <div class="fragment ribbon"><span>Live Code</span></div>

        </section>

        <section>

            <h3> REPL </h3>

            <p> Sequence char &rightarrow; Try Result </p>

        </section>

        <section>

            <h4> Read() <br>
                .map(Analyze).map(Transform).map.(Compile).flatmap(Execute) <br>
                .map(Print)
            </h4>

        </section>

        <section>

            <h3><span class="name">F&micro;N</span> in a browser </h3>

            <div style="font-size: 50%" onclick="bootstrap()">
                <code>fact &lt;i id='val'><i class="tk" id='val'>?</i>&lt;/i> = &lt;i id='res'><i class="tk" id='res'>?</i>&lt/i></code>
            </div>

            <script type="application/mfun">
    def compute_then_display { v ->
        do    { changeDom "val" v }
        then  { changeDom "res" $ fact v }
        yield { () }
    }

    compute_then_display 100

            </script>

            <pre class="fragment"><code class="html">  &lt;script type="application/mfun"></code><code class="mfun">    def compute_then_display { v ->
        do    { changeDom "val" v }
        then  { changeDom "res" $ fact v }
        yield { () }
    }

    compute_then_display 100</code><code class="html">  &lt;/script></code></pre>

            <div class="ribbon"><span class="name">F&micro;N inside</span></div>

        </section>
        <section>
            <h3> What's Next? </h3>

            <ul>
                <li> Call-by-Name</li>
                <li> Tail recursive</li>
                <li> Type checker</li>
                <li> G-Machine, SECD-Machine etc.</li>
            </ul>
        </section>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: false,
                progress: false,
                history: true,
                center: true,
                slideNumber: true,
                transition: 'none', // none/fade/slide/convex/concave/zoom

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    {
                        src: 'lib/js/classList.js', condition: function () {
                        return !document.body.classList;
                    }
                    },
                    {
                        src: 'plugin/markdown/marked.js', condition: function () {
                        return !!document.querySelector('[data-markdown]');
                    }
                    },
                    {
                        src: 'plugin/markdown/markdown.js', condition: function () {
                        return !!document.querySelector('[data-markdown]');
                    }
                    },
                    {
                        src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                        hljs.initHighlightingOnLoad();
                        // And register my language

                        // Disable all the auto detection
                        hljs.configure({languages: []});

                    }
                    },
                    {src: 'plugin/zoom-js/zoom.js', async: true},
                    {src: 'plugin/notes/notes.js', async: true}
                ]
            });
        </script>
</body>
</html>
